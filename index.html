<!DOCTYPE html>
<!-- 日本語の文書であることを示す -->
<html lang="ja">
<head>
<!-- 文字コードをUTF-8に設定 -->
<meta charset="UTF-8">
<!-- ブラウザのタブに表示されるタイトル -->
<title>3x3 スロットゲーム</title>
<!-- ここからスタイルシート（見た目の設定） -->
<style>
  /* ページ全体の基本スタイル */
  body {
    background: #222; /* 背景色を濃い灰色に */
    color: white; /* 文字色を白に */
    font-family: sans-serif; /* フォントの種類を指定 */
    text-align: center; /* 全ての要素を中央揃えに */
  }
  /* スロットマシン全体のコンテナ */
  .slot-container {
    display: inline-flex; /* リールを横並びにする */
    border: 5px solid #555; /* 枠線を設定 */
    background: #000; /* 背景色を黒に */
    padding: 10px; /* 内側の余白 */
    margin: 20px auto; /* 外側の余白 */
  }
  /* 各リールのスタイル */
  .reel {
    width: 80px; /* 幅 */
    height: 240px; /* 高さ（シンボル3つ分が見える高さ） */
    overflow: hidden; /* はみ出したシンボルを隠す */
    border: 2px solid #444; /* 枠線 */
    margin: 0 5px; /* 隣のリールとの間隔 */
    background: #111; /* 背景色 */
    position: relative; /* 子要素の配置の基準にする */
  }
  /* シンボルを縦に並べるためのコンテナ */
  .symbols {
    position: absolute; /* 親要素(.reel)を基準に絶対位置で配置 */
    top: 0; /* 上端を基準に */
    left: 0; /* 左端を基準に */
    right: 0; /* 右端を基準に */
  }
  /* 各シンボルのスタイル */
  .symbol {
    height: 80px; /* 高さ */
    font-size: 50px; /* 絵文字のサイズ */
    line-height: 80px; /* 高さと合わせて中央揃えにする */
  }
  /* ボタンの共通スタイル */
  button {
    margin: 10px; /* 外側の余白 */
    padding: 10px 20px; /* 内側の余白 */
    font-size: 16px; /* 文字サイズ */
  }
</style>
<!-- スタイルシートここまで -->
</head>
<body>

<!-- ゲームのメインタイトル -->
<h1>🎰 3x3 スロットゲーム 🎰</h1>

<!-- スロットマシンのHTML構造 -->
<div class="slot-container" id="slot">
  <!-- 3つのリールを配置 -->
  <div class="reel" id="reel0"><div class="symbols"></div></div>
  <div class="reel" id="reel1"><div class="symbols"></div></div>
  <div class="reel" id="reel2"><div class="symbols"></div></div>
</div>
<br>
<!-- 操作ボタン -->
<button id="startBtn">▶ スタート</button>
<button id="stopBtn">⏸ 停止（目押し）</button>
<button id="modeBtn">モード: 自動</button>

<!-- ここからJavaScript（ゲームのロジック） -->
<script>
// --- 設定値（ゲームバランスの調整はここで行う） ---
// シンボル関連
const SYMBOL_HEIGHT = 80; // px単位。CSSの.symbolのheightと合わせる
const symbols = ["🍒","🍋","🔔","⭐","7️⃣"]; // スロットのシンボル

// リール関連
const REEL_COUNT = 3; // リールの数
const AUTO_STOP_TIMINGS = [1000, 1600, 2200]; // 自動停止モードの各リール停止時間(ms)

// アニメーション関連
const maxSpeed = 7.5; // 最高速度（1フレームあたりのピクセル移動量）
const accelerationTime = 1000; // 最高速度に達するまでの時間(ms)
const MIN_STOP_ANIMATION_TIME = 100; // 停止アニメーションの最短時間(ms)
const MAX_STOP_ANIMATION_TIME = 1000; // 停止アニメーションの最長時間(ms)
// --- 設定値ここまで ---

// --- 内部変数（直接編集しない） ---
const reels = [];
for (let i = 0; i < REEL_COUNT; i++) {
  reels.push(document.querySelector(`#reel${i} .symbols`));
}
let spinning = new Array(REEL_COUNT).fill(false); // 各リールが回転中かどうかのフラグ
let animationFrameId = new Array(REEL_COUNT).fill(null); // アニメーションID
let modeAuto = true; // true:自動停止モード, false:目押しモード
let stopCount = 0; // 目押しモードで停止させたリールの数
// --- 内部変数ここまで ---

/**
 * 指定されたリールにシンボルをセットする関数
 */
function fillReel(reelEl) {
  reelEl.innerHTML = ''; // 中身を一旦空にする
  // シンボルの配列を2周分追加する（無限ループしているように見せるため）
  for (let i = 0; i < symbols.length * 2; i++) {
    let div = document.createElement('div');
    div.className = 'symbol';
    div.textContent = symbols[i % symbols.length];
    reelEl.appendChild(div);
  }
}

/**
 * 指定されたインデックスのリールを回転させる関数
 */
function startReel(index) {
  spinning[index] = true;
  // 現在のtop位置を取得。pxを削除し、数値に変換。初回は0。
  let pos = parseFloat(reels[index].style.top.replace('px', '')) * -1 || 0;
  // アニメーション開始時間を記録
  const startTime = performance.now();

  function animate(currentTime) {
    // 停止フラグが立っていたらアニメーションを終了
    if (!spinning[index]) return;

    // 経過時間
    const elapsed = currentTime - startTime;
    let currentSpeed;

    // 加速処理
    if (elapsed < accelerationTime) {
      // 加速時間内であれば、経過時間に応じて速度を上げる (ease-in効果)
      const progress = elapsed / accelerationTime; // 0から1への進捗度
      const ease = progress * progress * progress; // easeInCubic: 最初はゆっくりで、だんだん速くなる
      currentSpeed = maxSpeed * ease;
    } else {
      // 加速時間を超えたら最高速度を維持
      currentSpeed = maxSpeed;
    }

    // 新しい位置を計算。シンボル全体の高さを超えたら0に戻す（ループさせる）
    pos = (pos + currentSpeed) % (symbols.length * SYMBOL_HEIGHT);
    // 新しい位置をstyleに適用
    reels[index].style.top = -pos + 'px';

    // 次のフレームで再度animate関数を呼び出す
    animationFrameId[index] = requestAnimationFrame(animate);
  }
  // アニメーションを開始
  requestAnimationFrame(animate);
}

/**
 * 指定されたインデックスのリールを停止させる関数
 */
function stopReel(index) {
  // すでに停止しているか、回転中でなければ何もしない
  if (!spinning[index]) return;

  // 回転アニメーションをキャンセル
  cancelAnimationFrame(animationFrameId[index]);

  // 現在のリールのY軸位置を取得
  let currentTop = parseInt(reels[index].style.top || '0');
  // シンボルリスト1周分の合計の高さ
  const totalSymbolHeight = symbols.length * SYMBOL_HEIGHT;
  // 現在の位置をシンボル1周分の高さで正規化（剰余を計算）
  let posMod = ((-currentTop) % totalSymbolHeight + totalSymbolHeight) % totalSymbolHeight;
  // 最も近い停止位置（シンボルの上端）からのズレを計算
  let remainder = posMod % SYMBOL_HEIGHT;
  // 次のシンボルの上端にぴったり停止するための移動距離を計算
  let distanceToNext = (SYMBOL_HEIGHT - remainder) % SYMBOL_HEIGHT;

  // 停止アニメーションにかける時間を計算。移動距離が長いほど少し長くする
  let timeNeeded = Math.ceil(distanceToNext / maxSpeed) * 20;
  // アニメーション時間が極端に短/長くなりすぎないように、最小値と最大値の範囲に収める
  timeNeeded = Math.min(Math.max(timeNeeded, MIN_STOP_ANIMATION_TIME), MAX_STOP_ANIMATION_TIME);

  // 停止アニメーションの開始時間と開始位置を記録
  const start = performance.now();
  const startTop = currentTop;
  // 最終的な停止位置を計算
  const targetTop = currentTop - distanceToNext;

  // 停止アニメーション用の関数
  function animateStop(now) {
    // 経過時間と進捗度(0-1)を計算
    let elapsed = now - start;
    let progress = Math.min(elapsed / timeNeeded, 1);
    // イージング（ease-out効果）を適用して、だんだんゆっくり停止するように見せる
    let ease = 1 - Math.pow(1 - progress, 3); // easeOutCubic
    // 現在の位置を計算してstyleに適用
    reels[index].style.top = startTop - (distanceToNext * ease) + 'px';

    // アニメーションが完了していなければ、次のフレームを要求
    if (progress < 1) {
      requestAnimationFrame(animateStop);
    } else {
      // アニメーション完了後
      spinning[index] = false; // 停止フラグを立てる
      reels[index].style.top = targetTop + 'px'; // 最終位置に正確に設定
    }
  }
  // 停止アニメーションを開始
  requestAnimationFrame(animateStop);
}

/**
 * ゲームを開始する関数
 */
function startGame() {
  stopCount = 0;
  for (let i = 0; i < REEL_COUNT; i++) {
    startReel(i);
  }
  if (modeAuto) {
    AUTO_STOP_TIMINGS.forEach((time, index) => {
      setTimeout(() => stopReel(index), time);
    });
  }
}

/**
 * 目押しモードで手動停止する関数
 */
function stopManual() {
  if (modeAuto) return;
  if (stopCount < REEL_COUNT) {
    stopReel(stopCount);
    stopCount++;
  }
}

// --- イベントリスナーの設定 ---

document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('stopBtn').addEventListener('click', stopManual);
document.getElementById('modeBtn').addEventListener('click', () => {
  modeAuto = !modeAuto;
  document.getElementById('modeBtn').textContent = 'モード: ' + (modeAuto ? '自動' : '目押し');
});

// --- 初期化処理 ---
reels.forEach(fillReel);

</script>
<!-- JavaScriptここまで -->
</body>
</html>